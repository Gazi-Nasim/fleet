{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.typeImplementation = typeImplementation;\nvar _utils = require(\"../utils\");\nvar _click = require(\"../click\");\nvar _keyboard = require(\"../keyboard\");\nasync function typeImplementation(element, text, _ref) {\n  let {\n    delay,\n    skipClick = false,\n    skipAutoClose = false,\n    initialSelectionStart = undefined,\n    initialSelectionEnd = undefined\n  } = _ref;\n  // TODO: properly type guard\n  // we use this workaround for now to prevent changing behavior\n  if (element.disabled) return;\n  if (!skipClick) (0, _click.click)(element); // The focused element could change between each event, so get the currently active element each time\n\n  const currentElement = () => (0, _utils.getActiveElement)(element.ownerDocument); // by default, a new element has its selection start and end at 0\n  // but most of the time when people call \"type\", they expect it to type\n  // at the end of the current input value. So, if the selection start\n  // and end are both the default of 0, then we'll go ahead and change\n  // them to the length of the current value.\n  // the only time it would make sense to pass the initialSelectionStart or\n  // initialSelectionEnd is if you have an input with a value and want to\n  // explicitly start typing with the cursor at 0. Not super common.\n\n  const value = (0, _utils.getValue)(currentElement());\n  const {\n    selectionStart,\n    selectionEnd\n  } = (0, _utils.getSelectionRange)(element);\n  if (value != null && (selectionStart === null || selectionStart === 0) && (selectionEnd === null || selectionEnd === 0)) {\n    (0, _utils.setSelectionRange)(currentElement(), initialSelectionStart != null ? initialSelectionStart : value.length, initialSelectionEnd != null ? initialSelectionEnd : value.length);\n  }\n  const {\n    promise,\n    releaseAllKeys\n  } = (0, _keyboard.keyboardImplementationWrapper)(text, {\n    delay,\n    document: element.ownerDocument\n  });\n  if (delay > 0) {\n    await promise;\n  }\n  if (!skipAutoClose) {\n    releaseAllKeys();\n  } // eslint-disable-next-line consistent-return -- we need to return the internal Promise so that it is catchable if we don't await\n\n  return promise;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","typeImplementation","_utils","require","_click","_keyboard","element","text","_ref","delay","skipClick","skipAutoClose","initialSelectionStart","undefined","initialSelectionEnd","disabled","click","currentElement","getActiveElement","ownerDocument","getValue","selectionStart","selectionEnd","getSelectionRange","setSelectionRange","length","promise","releaseAllKeys","keyboardImplementationWrapper","document"],"sources":["D:/Xampp/htdocs/fleet/frontend/node_modules/@testing-library/user-event/dist/type/typeImplementation.js"],"sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.typeImplementation = typeImplementation;\r\n\r\nvar _utils = require(\"../utils\");\r\n\r\nvar _click = require(\"../click\");\r\n\r\nvar _keyboard = require(\"../keyboard\");\r\n\r\nasync function typeImplementation(element, text, {\r\n  delay,\r\n  skipClick = false,\r\n  skipAutoClose = false,\r\n  initialSelectionStart = undefined,\r\n  initialSelectionEnd = undefined\r\n}) {\r\n  // TODO: properly type guard\r\n  // we use this workaround for now to prevent changing behavior\r\n  if (element.disabled) return;\r\n  if (!skipClick) (0, _click.click)(element); // The focused element could change between each event, so get the currently active element each time\r\n\r\n  const currentElement = () => (0, _utils.getActiveElement)(element.ownerDocument); // by default, a new element has its selection start and end at 0\r\n  // but most of the time when people call \"type\", they expect it to type\r\n  // at the end of the current input value. So, if the selection start\r\n  // and end are both the default of 0, then we'll go ahead and change\r\n  // them to the length of the current value.\r\n  // the only time it would make sense to pass the initialSelectionStart or\r\n  // initialSelectionEnd is if you have an input with a value and want to\r\n  // explicitly start typing with the cursor at 0. Not super common.\r\n\r\n\r\n  const value = (0, _utils.getValue)(currentElement());\r\n  const {\r\n    selectionStart,\r\n    selectionEnd\r\n  } = (0, _utils.getSelectionRange)(element);\r\n\r\n  if (value != null && (selectionStart === null || selectionStart === 0) && (selectionEnd === null || selectionEnd === 0)) {\r\n    (0, _utils.setSelectionRange)(currentElement(), initialSelectionStart != null ? initialSelectionStart : value.length, initialSelectionEnd != null ? initialSelectionEnd : value.length);\r\n  }\r\n\r\n  const {\r\n    promise,\r\n    releaseAllKeys\r\n  } = (0, _keyboard.keyboardImplementationWrapper)(text, {\r\n    delay,\r\n    document: element.ownerDocument\r\n  });\r\n\r\n  if (delay > 0) {\r\n    await promise;\r\n  }\r\n\r\n  if (!skipAutoClose) {\r\n    releaseAllKeys();\r\n  } // eslint-disable-next-line consistent-return -- we need to return the internal Promise so that it is catchable if we don't await\r\n\r\n\r\n  return promise;\r\n}"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,kBAAkB,GAAGA,kBAAkB;AAE/C,IAAIC,MAAM,GAAGC,OAAO,CAAC,UAAU,CAAC;AAEhC,IAAIC,MAAM,GAAGD,OAAO,CAAC,UAAU,CAAC;AAEhC,IAAIE,SAAS,GAAGF,OAAO,CAAC,aAAa,CAAC;AAEtC,eAAeF,kBAAkBA,CAACK,OAAO,EAAEC,IAAI,EAAAC,IAAA,EAM5C;EAAA,IAN8C;IAC/CC,KAAK;IACLC,SAAS,GAAG,KAAK;IACjBC,aAAa,GAAG,KAAK;IACrBC,qBAAqB,GAAGC,SAAS;IACjCC,mBAAmB,GAAGD;EACxB,CAAC,GAAAL,IAAA;EACC;EACA;EACA,IAAIF,OAAO,CAACS,QAAQ,EAAE;EACtB,IAAI,CAACL,SAAS,EAAE,CAAC,CAAC,EAAEN,MAAM,CAACY,KAAK,EAAEV,OAAO,CAAC,CAAC,CAAC;;EAE5C,MAAMW,cAAc,GAAGA,CAAA,KAAM,CAAC,CAAC,EAAEf,MAAM,CAACgB,gBAAgB,EAAEZ,OAAO,CAACa,aAAa,CAAC,CAAC,CAAC;EAClF;EACA;EACA;EACA;EACA;EACA;EACA;;EAGA,MAAMnB,KAAK,GAAG,CAAC,CAAC,EAAEE,MAAM,CAACkB,QAAQ,EAAEH,cAAc,EAAE,CAAC;EACpD,MAAM;IACJI,cAAc;IACdC;EACF,CAAC,GAAG,CAAC,CAAC,EAAEpB,MAAM,CAACqB,iBAAiB,EAAEjB,OAAO,CAAC;EAE1C,IAAIN,KAAK,IAAI,IAAI,KAAKqB,cAAc,KAAK,IAAI,IAAIA,cAAc,KAAK,CAAC,CAAC,KAAKC,YAAY,KAAK,IAAI,IAAIA,YAAY,KAAK,CAAC,CAAC,EAAE;IACvH,CAAC,CAAC,EAAEpB,MAAM,CAACsB,iBAAiB,EAAEP,cAAc,EAAE,EAAEL,qBAAqB,IAAI,IAAI,GAAGA,qBAAqB,GAAGZ,KAAK,CAACyB,MAAM,EAAEX,mBAAmB,IAAI,IAAI,GAAGA,mBAAmB,GAAGd,KAAK,CAACyB,MAAM,CAAC;EACzL;EAEA,MAAM;IACJC,OAAO;IACPC;EACF,CAAC,GAAG,CAAC,CAAC,EAAEtB,SAAS,CAACuB,6BAA6B,EAAErB,IAAI,EAAE;IACrDE,KAAK;IACLoB,QAAQ,EAAEvB,OAAO,CAACa;EACpB,CAAC,CAAC;EAEF,IAAIV,KAAK,GAAG,CAAC,EAAE;IACb,MAAMiB,OAAO;EACf;EAEA,IAAI,CAACf,aAAa,EAAE;IAClBgB,cAAc,EAAE;EAClB,CAAC,CAAC;;EAGF,OAAOD,OAAO;AAChB"},"metadata":{},"sourceType":"script","externalDependencies":[]}